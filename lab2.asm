
Цепочка открыта. Сообщений: 8. Все сообщения прочитаны.

Перейти к содержимому
Gmail используется с программой чтения с экрана
3 из 44
Лабораторная 5
Входящие
Дмитрий Тимченко
	
	Приложенияпн, 20 нояб., 17:19
Добрый вечер, написал код к лабораторной по RISC-V, не могли бы вы подсказать, это то, что нужно, или я что-то делаю не так(сделал 3 теста, прога их прошла), во
Морозов Сергей
	
	пн, 20 нояб., 19:51
Приветствую. Суть поняли верно, но есть тонкости: 1. Не забывайте в каких регистрах надо располагать результаты вычислений. 2. call, ret, mv в коде отсутствуют.
Дмитрий Тимченко <gidra.mac@gmail.com>
	
Приложениясб, 25 нояб., 13:52
	
кому: Морозов
Добрый день, вроде выполнил все указанные пункты, едиснтвенно оказалась проблема, не получается вставить цели работы, если вставляю их, то они расползаются на 7-8 страниц(как будто разрывы страниц, но их там нет), код и отчет в формате pdf приложил.
С уважением,
Студент группы 2384,
Тимченко Дмитрий.

пн, 20 нояб. 2023 г. в 19:51, Морозов Сергей <frostsergei01@gmail.com>:
 2 прикрепленных файла  • Просканировано системой Gmail
Морозов Сергей
	
сб, 25 нояб., 17:19
	
кому: мне
1. Разберитесь с оформлением целей в таком случае. Проверьте непечатаемые символы, вдруг что мешает. Отчет предполагается немаленький.
2. Вставьте в отчет 1-2 теста на отрицательных значениях входных переменных x,y,z.
3. К оформлению в целом некоторые вопросы, так как есть моменты не по универским стандартам. Первое, что бросается в глаза - выравнивание текста сделано по левому краю (по стандартам оно должно быть по ширине).

К программе вопросов нет.
--
С уважением,
Морозов Сергей.
Дмитрий Тимченко <gidra.mac@gmail.com>
	
Приложениясб, 25 нояб., 18:46
	
кому: Морозов
Все пофиксил, тесты добавил, прикрепил отчет в формате pdf
С уважением,
Студент группы 2384,
Тимченко Дмитрий.

сб, 25 нояб. 2023 г. в 17:19, Морозов Сергей <frostsergei01@gmail.com>:
Один прикрепленный файл  • Просканировано системой Gmail
Морозов Сергей
	
	сб, 25 нояб., 19:13
Принимается. Вопросы на защиту были даны в файле с заданием. Ответьте на первые 8 вопросов и на вопрос 10. Можно текстом в письме, можно отдельным файлом.
Дмитрий Тимченко <gidra.mac@gmail.com>
	
вс, 26 нояб., 18:15
	
кому: Морозов
1)Группы команд в базовом наборе RISC-V:
Арифметические и логические команды: ADD, SUB, AND, OR, XOR, etc.
Команды передачи данных: LOAD, STORE, MOVE, etc.
Управляющие команды: BRANCH (BEQ, BNE, BLT, BGE, etc.), JAL, JALR, etc.

2)Назначение и отличие команд JAL и JALR:
JAL (Jump and Link): Безусловный переход с сохранением адреса следующей инструкции в регистре (обычно ra).
JALR (Jump and Link Register): Безусловный переход с сохранением адреса следующей инструкции в регистре, адрес для перехода берется из регистра.

3)Реализация простого безусловного перехода:
Используется команда ветвления, например, J или JAL с соответствующим адресом.
Отличия систем команд Intel x86 и RISC-V:

4)RISC-V представляет собой архитектуру с фиксированным набором команд, в то время как x86 является CISC (Complex Instruction Set Computing) и имеет более сложный и разнообразный набор команд.
x86 использует переменную длину команд, тогда как в RISC-V длина команд фиксирована.
RISC-V имеет меньше инструкций, что облегчает декодирование и исполнение.

5)Типы основных директив ассемблера RISC-V:
.text: Объявление секции кода.
.data: Объявление секции данных.
.globl: Объявление глобальной метки.

6)Состав и назначение регистров RISC-V:
Integer registers (x0 - x31): Для целочисленных вычислений.
Floating-point registers (f0 - f31): Для операций с плавающей запятой.
Special registers: Например, pc (Program Counter), ra (Return Address), sp (Stack Pointer).

7)Назначение и особенности псевдокоманд RISC-V:
Pseudoinstructions: Удобные абстракции, которые могут быть заменены на несколько базовых инструкций. Например, NOP (No Operation).

8)Реализация псевдокоманд вызова процедуры и возврата из процедуры:

Вызов процедуры может быть реализован с использованием команды JAL.
Возврат из процедуры может быть реализован с использованием команды JALR с возвратом на адрес, сохраненный в регистре ra.

10)Информация в 32-битном коде машинной инструкции RISC-V:
Opcode: Определяет операцию.
Регистры: Идентифицируют источники данных, целевой регистр и дополнительные регистры для некоторых команд.
Immediate values: Константы, значения, смещения и другие данные, которые необходимы для выполнения инструкции
С уважением,
Студент группы 2384,
Тимченко Дмитрий.


сб, 25 нояб. 2023 г. в 19:13, Морозов Сергей <frostsergei01@gmail.com>:
Морозов Сергей
	
вс, 26 нояб., 18:21
	
кому: мне
Принимается.
--
С уважением,
Морозов Сергей.
	

.data
a: .word 22  # Константа a
b: .word 8   # Константа b
c: .word 7   # Константа c

x1: .word 5 # Набор значений {x1, y1, z1}
x2: .word 9  # Набор значений {x2, y2, z2}
y1: .word 2
y2: .word 3
z1: .word 5
z2: .word 6
msg_a: .asciz "a: "
msg_b: .asciz "b: "
msg_c: .asciz "c: "
msg_for: .asciz "Формула для расчетов: ((y ^ a) - (z >> b)) - (x ^ (-c)) "
msg_res1: .asciz "Результат для x1, y1, z1: "
msg_res2: .asciz "Результат для x2, y2, z2: "
r1: .word 0  # Регистры для сохранения результатов вычислений
r2: .word 0
.text

main:
la a0, msg_a  # где msg_a соответствущее объявление строк: .asciz "a: "
li a7, 4
ecall    
lw a0, a
li a7, 1
ecall
la a0, 10   # Загрузка кода ASCII для новой строки
li a7, 11   # Выбираем системный вызов для вывода символа
ecall       # Вызываем системный вызов (вывод на экран)
la a0, msg_b  # где msg_b соответствущее объявление строк: .asciz "b: "
li a7, 4
ecall 
lw a0, b
li a7, 1
ecall
la a0, 10   # Загрузка кода ASCII для новой строки
li a7, 11   # Выбираем системный вызов для вывода символа
ecall       # Вызываем системный вызов (вывод на экран)
la a0, msg_c  # где msg_c соответствущее объявление строк: .asciz "c: "
li a7, 4
ecall 
lw a0, c
li a7, 1
ecall
la a0, 10   # Загрузка кода ASCII для новой строки
li a7, 11   # Выбираем системный вызов для вывода символа
ecall       # Вызываем системный вызов (вывод на экран)
la a0, msg_for
li a7, 4
ecall
la a0, 10   # Загрузка кода ASCII для новой строки
li a7, 11   # Выбираем системный вызов для вывода символа
ecall       # Вызываем системный вызов (вывод на экран)
lw a0, a  # Загружаем константы в соответствующие регистры для последующих операций
lw a1, b
lw a2, c

lw a3, x1  # Загружаем набор данных {x1, y1, z1}
lw a4, y1
lw a5, z1
la s10, r1  # Адрес для записи результата вычисления
call computate  # Вызов процедуры вычисления
lw a3, x2  # Загружаем набор данных {x2, y2, z2}
lw a4, y2
lw a5, z2
la s10, r2  # Адрес для записи результата вычислений
call computate  # Вызов процедуры вычисления
la a0, msg_res1  # где msg_res1 соответствущее объявление строк: .asciz "Результат для набора x1, y1, z1: "
li a7, 4
ecall   
lw a0, r1  # Загружаем результат первой операции для вывода
li a7, 1   # Выбираем системный вызов для вывода целого числа
ecall       # Вызываем системный вызов (вывод на экран)
la a0, 10   # Загрузка кода ASCII для новой строки
li a7, 11   # Выбираем системный вызов для вывода символа
ecall       # Вызываем системный вызов (вывод на экран)
la a0, msg_res2  # где msg_res2 соответствущее объявление строк: .asciz "Результат для набора x2, y2, z2: "
li a7, 4
ecall 
lw a0, r2  # Загружаем результат второй операции для вывода
li a7, 1   # Выбираем системный вызов для вывода целого числа
ecall       # Вызываем системный вызов (вывод на экран)
lw a1, r1  # Загружаем результаты
lw a2, r2
li a7, 10  # Выбираем системный вызов для завершения программы
ecall       # Вызываем системный вызов (завершение программы)

computate:
    xor t0, a4, a0  # t0 = y^a
    sra t1, a5, a1  # t1 = z>>b
    sub t2, t0, t1  # t2 = (y^a) - (z>>b)
    neg t3, a2      # t3 = -c
    xor t4, a3, t3  # t4 = x^(-c)
    sub a6, t2, t4  # a6 = ((y^a) - (z>>b)) - (x^(-c))
    sw a6, 0(s10)   # Сохраняем результат в выбранном регистре
    ret          # Возвращаемся в вызывающую процедуру

Timchenko_lb5.txt
Отображается файл "Timchenko_lb5.txt"
